# Mysql

###  1、存储引擎

MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。

* InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
* InnoDB 默认使用的 **REPEATABLE-READ（可重读）**隔离级别是**可以解决幻读问题**发生的，基于 MVCC（**多版本并发控制**，也叫快照读） 和 Next-Key Lock（是行锁（Record Lock）和间隙锁（Gap Lock）的结合）。
* MyISAM 不支持外键，而 InnoDB 支持。
* maMyISAM 不支持**数据库异常崩溃后的安全恢复**，而 InnoDB 支持。这个恢复的过程依赖于 `redo log` 。
* MyISAM 不支持**MVCC**，而 InnoDB 支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。
* 索引实现不一样。都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。MyISAM索引文件和数据文件是分离的，InnoDB 引擎中，其数据文件本身就是索引文件。树的叶节点 data 域保存了完整的数据记录。**InnoDB** 使用聚簇索引，而MyISAM不是。
* 数据缓存策略和机制实现不同。InnoDB 使用**缓冲池**（Buffer Pool）缓存数据页和索引页，MyISAM 使用键缓存（Key Cache）仅缓存索引页而不缓存数据页。







###  2、Mysql事务隔离级别

事务隔离级别决定了多个事务之间可以互相影响的程度，例如：

​	•	事务 A 是否可以看到事务 B 尚未提交的数据？

​	•	事务 A 是否允许在其读取的数据上，事务 B 进行修改或插入？

不可重复读：**其他事务对已存在数据的修改**

幻读：**其他事务对数据集合的插入或删除**。

解决幻读的方法：

* 事务隔离级别调整为可串行化。
* 在可重复读的事务级别下，给事务操作的这张表添加表锁。
* 在可重复读的事务级别下，给事务操作的这张表添加Next-Key Lock（执行 `insert` 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。）。

可重复读的隔离级别下可以选择两种方式：

* 一致性非锁定读方式：MVCC，保证了可重复读。只读取事务开始时的一致性快照，不受记录修改插入的影响。但这只避免了部分幻读，因为若是采用锁定读时，要读取最新的快照了，就必须得防止幻读。
* 锁定读方式：Next-Key Lock（Record Lock和Gap Lock），解决了幻读。

如何实现从读已提交到可重复读：select时创建readview时机不同。

可串行化隔离级别下：

在实际的分布式事务中，并不总是依赖数据库的 SERIALIZABLE 隔离级别。通常有其他分布式一致性方案。

排他锁会阻止其他可串行化事务的读取操作，因为可串行化事务读取本身会加锁。而在**读已提交和可重复读**隔离级别下，会读取快照数据，不会被排他锁阻塞。

###  3、Mysql索引

用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

优点：使用索引减少IO，创建唯一索引保证每一行数据的唯一性。

缺点：创建和维护索引耗时，且耗空间。

#### 底层数据结构选择：

* Hash表：速度快，但不支持顺序和范围查询，每次IO只能取一个。

* AVL树：频繁旋转操作有较大的计算开销，降低数据库写的性能。也需要多次IO。

* 红黑树：插入和删除节点（**时间复杂度为log(N)**)只需进行少量的旋转和变色操作。并不追求严格的平衡，而是大致的平衡。平衡性相对较弱，可能会导致树的**高度较高**，这可能会导致一些数据需要进行**多次磁盘 IO 操作**才能查询到，这也是 MySQL 没有选择红黑树的主要原因。TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。

* 为什么不用跳表：

  > 磁盘IO效率：B+树多路搜索树，树的高度低，减少磁盘IO次数。相同高度容纳更多记录。而跳表不是为磁盘优化的，会导致大量的随机磁盘访问。

* B 树& B+树（**时间复杂度全为logd（N),**d是B&B+树的阶）：

  区别：

  > B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。

  > 叶节点一条链：B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。

  > **查找稳定**：B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

  >  B树要分别查找上限和下限。**B+树的范围查询**，只需要对链表进行遍历即可。

  综上：B+树具有更少的IO，更稳定查询效率和适于范围查找。

#### **聚簇索引（主键索引）**

主键索引即为聚簇索引，表中的数据行实际存储在主索引的叶子节点上。聚簇索引的每个叶子节点包含主键值和整行数据。

优点：对于主键的**排序查找和范围查找**速度也非常快。相比于非聚簇索引， 聚簇索引**少了一次读取数据的 IO 操作**。

缺点：更新代价大，主键一般不可修改。依赖有序的数据，插入时排序。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

#### 辅助索引（二级索引）

除主键外，其他字段上建立的索引称为辅助索引。辅助索引的叶子节点中存储的是**被索引字段的值和相应的主键值。**

缺点：**可能会二次查询(回表)**

---

还有唯一索引、**全文索引**（目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。）、前缀索引（仅限于字符串类型）和普通索引。

---

#### 覆盖索引

覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。

#### 联合索引

使用表中的多个字段创建索引，就是 联合索引。**尽可能的考虑建立联合索引而不是单列索引**：节约磁盘空间。

#### 最左前缀匹配原则

假设有一个联合索引`(column1, column2, column3)`，其从左到右的所有前缀为`(column1)`、`(column1, column2)`、`(column1, column2, column3)`（创建 1 个联合索引相当于创建了 3 个索引），包含这些列的所有查询都会走索引而不会全表扫描。(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。**利用索引的前提是索引里的 key 是有序的**。

联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」（如 >、<）就会停止匹配。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配。**也就是范围查询的字段可以用到联合索引，但是范围查询字段的后面的字段无法用到联合索引**。

*  **a > 1 and b = 2。**a 字段使用了 > 进行范围查询，联合索引的最左匹配原则在遇到 a 字段的范围查询（ >）后就停止匹配了，因此 b 字段并没有使用到联合索引。
*  **a >= 1 and b = 2。**虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的，从符合 a = 1 and b = 2 条件的第一条记录开始扫描。所以a、b都用到了联合索引。
* **a BETWEEN 2 AND 8 AND b = 2。**在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =<。用到了联合索引。
* **name like 'j%' and age = 22。**前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的。在确定需要扫描的二级索引的范围时，当二级索引记录的 name 字段值为 ‘j’ 时，可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 name = 'j' and age = 22 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描 。

#### 索引下推

**除了可以减少回表次数之外，索引下推还可以减少存储引擎层和 Server 层的数据传输量。**

对于联合索引`(zipcode, birthdate)`。**没有索引下推**：存储引擎层先根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户的主键 ID，然后二次回表查询，返回户数据给 Server 层，由Server层筛选`MONTH(birthdate) = 3`。**有了索引下推之后：**全部由存储引擎层回表查询筛选字段后再返回给Server层。

**注意事项：**

* 对于 InnoDB 表，仅用于非聚簇索引。索引下推的目标是减少全行读取次数，从而减少 I/O 操作。对于 InnoDB 聚集索引，完整的记录已经读入 **InnoDB 缓冲区**。在这种情况下使用索引下推 不会减少 I/O。
* 适用于 InnoDB 引擎和 MyISAM 引擎的查询。
* 子查询不能使用索引下推，因为子查询通常会创建临时表来处理结果，而这些临时表是没有索引的。

#### 索引失效

* 查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到。
* IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同)。
* 创建了联合索引，但查询条件未遵守最左匹配原则。

### 4、Mysql并发控制方式

#### **MVCC**

 MVCC是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个**全局的版本分配器**来为每一行数据设置版本号，版本号是唯一的。数据修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。

* **写操作时**：原始版本的数据仍然存在，供其他事务使用快照读取。新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。
* **读取时**，读取的行正在执行 `DELETE` 或 `UPDATE` 操作（说明上了锁），这时读取操作不会去等待行上锁的释放，而是去快照读（这就是MVCC的机制）。

>  `InnoDB` 在实现`Repeatable Read` 时，如果执行的是当前读（锁定读，需要加锁），则会对读取的记录使用 `Next-key Lock` ，来防止其它事务在间隙间插入数据，进而防止了幻读。在 `一致性非锁定读` 情况下，只能读取到第一次查询之前所插入的数据，这就代表了在 `Repeatable Read` 下 `MVCC` 防止了幻读。

MVCC 在 MySQL 中实现所依赖的手段主要是: **隐藏字段、read view、undo log**。

* 隐藏字段：`DB_TRX_ID（6字节）`，表示最后一次插入或更新该行的事务 id。

* undo log 用于记录某行数据的多个版本的数据。

* read view有活跃列表，只有在活跃列表中找到`DB_TRX_ID`,就可以判断不可见。

* read view 和 隐藏字段 : 用来判断当前版本数据的可见性，不可见就去undo log取快照。

  

##### **RC和RR的区别：**

虽然 RC 和 RR 都通过 `MVCC` 来读取快照数据，但由于 **生成 Read View 时机不同**，从而在 RR 级别下实现可重复读。前者每次select时生成read view，后者只在第一次select时生成。

在 RR 级别下，对于快照数据，一致性非锁定读总是读取**本事务开始时**的行数据版本。在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的**最新一份快照**数据。



#### Mysql锁

查询时：由于 MVCC 的存在，对于一般的 `SELECT` 语句，InnoDB 不会加任何锁。但是，有时候需要当前读，就需要加共享锁或排他锁。

##### 行级锁

InnoDB 的行锁是通过对索引数据页上的记录加锁实现的，表级锁是针对非索引字段加的锁。当我们执行 `UPDATE`、`DELETE` 语句时，如果 `WHERE`条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！

**如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。**因为这些索引的值是确定的，不可能有重复值。



##### 意向锁

意向锁可以用来快速判断是否可以对某个表使用表锁。

* 事务对某些行加锁之前，必须先在表上加意向锁。对表加锁不需要加意向锁。
* 意向锁不会与其他事务的行级的共享锁和排他锁互斥。
* 意向锁由 InnoDB 自动管理，用户无需手动干预。

意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁）。

|      | IS 锁 | IX 锁 |
| ---- | ----- | :---: |
| S 锁 | 兼容  | 互斥  |
| X 锁 | 互斥  | 互斥  |



##### 自增锁

如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。

不能解决 MySQL 自增主键不连续的问题。

* 想要解决这个问题的终极方案是串行执行所有包含插入操作的事务，也就是使用数据库的最高隔离级别 —— 可串行化（Serialiable）。实现完全串行的插入也可以保证主键**在插入时的连续**，但是仍然不能避免删除数据导致的不连续。
* MySQL 中不连续的主键又是一个**工程设计向性能低头**的例子，牺牲主键的连续性来支持数据的并发插入，最终提高了 MySQL 服务的吞吐量

使用重做日志解决，保证了主键的单调性。

尽管不单调或不连续，MySQL 的自增主键仍能保证主键的唯一性，满足大多数业务需求。如果需要严格的连续性，可以通过业务逻辑或其他主键生成方式（如**分布式 ID**）来实现。

* **分布式唯一 ID 生成器**（如雪花算法 Snowflake）。

### 5、读写分离和分库分表

读写分离解决并发压力，分库分表解决存储压力。

canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。

避免主从延迟：写完主库之后，主库的数据同步到从库是需要时间的，强制将读请求路由到主库处理。

分库分表带来的挑战：

* **分布式 ID**：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。引入分布式 ID，为不同的数据节点生成全局唯一主键。
* 跨库聚合问题。
* **join 操作**：`JOIN` 操作用于将两个或多个表中的行组合在一起。同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。join 的效率低，并且会对分库分表造成影响。对于需要用到 join 操作的地方，可以采用**多次查询业务层进行数据组装**的方法。
* **事务问题**：同一个数据库中的表分布在了不同的数据库中，数据库自带的事务就无法满足我们的要求了，引入分布式事务。

#### 分布式ID方案

* 数据库自增：简单但每次获取 ID 都要访问一次数据库。而且有安全问题。

* 数据库的号段模式：ID批量获取，然后存在在内存里面。数据库的号段模式对于数据库的访问次数更少，数据库压力更小。有安全问题。

* Redis方案：为了提高可用性和并发，我们可以使用 Redis Cluster。和数据库主键自增方案的缺点类似。

* UUID： Universally Unique Identifier（通用唯一标识符）。数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大、无序（非自增）。

* 雪花算法：包含了符号位，时间戳、机房机器ID和序列号

  > **优点**：生成速度比较快、生成的 ID 有序递增、比较灵活(进行简单的改造比如加入业务 ID)
  >
  > 缺点：需要解决重复 ID 问题（由于时间回拨），依赖机器 ID 不够灵活



### 6、Mysql日志

#### 慢查询日志

用于记录执行时间超过指定阈值的查询语句。通过分析慢查询日志，可以识别和优化性能较差的查询，从而提高数据库的整体性能。

#### redo log（重做日志）

**关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）**，这一机制称为预写日志（**WAL**）。

是物理日志，记录了数据页在内存中的实际变化。**是 InnoDB 存储引擎独有的**，它让 MySQL 拥有了崩溃恢复能力。用于事务的持久化和故障恢复。

更新时，就直接在 `Buffer Pool` 里更新，把做的修改记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 redo log 文件里， redo log 文件在磁盘里。

刷盘时机：

* 事务提交、`redo log buffer`空间不足
* 后台刷新线程，InnoDB 存储引擎有一个后台线程，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。
* .....

不同的**刷盘策略**：每次事务提交时刷盘、提交不刷盘以及每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）。默认为**提交就刷盘。**

InnoDB 存储引擎有一个后台线程，每隔`1` 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。所以，MySQL 宕机之后可能会存在轻微的数据丢失问题。



#### binlog（二进制日志、归档日志）

是逻辑日志，记录的是SQL语句的逻辑操作，属于`MySQL Server` 层。用于数据备份和主从复制，保证了 MySQL 集群架构的数据一致性。

三种格式：

* statement。`SQL`语句原文。使用非确定性的函数如`update_time=now()`，这里会获取当前系统时间，直接执行会导致与原库的数据不一致，所以需要row格式。
* row。记录的是每一行数据的变化，记录的内容看不到详细信息，但能保证同步数据的一致性。但是比较占用空间，恢复与同步时会更消耗 IO 资源，影响执行速度。
* Mixed。判断这条`SQL`语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式。

写入机制：

事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到 page cache中，再通过fsync持久化到磁盘里。

**redo log 在事务执行过程中可以不断写入，而 binlog 只有在提交事务时才写入。**

> binlog没有那种，每隔`1` 秒就调用 `fsync` 刷盘的机制，必须提交事务后才写入。

#### 两阶段提交

为了解决两份日志之间的逻辑一致问题（会导致主从库或恢复状态不一致），InnoDB 存储引擎使用**两阶段提交**方案。

将 redo log 的写入拆成了两个步骤`prepare`和`commit`。

* redo log 还处于`prepare`阶段，并且没有对应 binlog 日志，就会回滚该事务。
* redo log 设置`commit`阶段发生异常，但是 binlog 日志写入成功，MySQL 会根据 Binlog 重放事务，确保数据一致性。

---

**MySQL 不直接使用 Redo Log 进行主从复制，而需要使用 Binlog，主要是基于功能分离、灵活性和效率的考虑。**

* Redo log依赖于存储引擎的实现。Binlog 是逻辑日志，能够跨架构使用（从库可以是与主库不同的架构，如不同的存储引擎）。
* 物理修改只能还原某些具体的数据页状态，无法重现 SQL 的逻辑。逻辑操作可以在从库中重新执行，适合主从同步。



#### undo log

u··ndo log 属于逻辑日志，记录的是 SQL 语句。undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。undo-log 本身是会被删除清理的。



> 总结：MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。**数据备份、主备、主主、主从**都离不开 binlog。

## 7、数据库缓存

分布式缓存：redis

本地缓存：Guava Cache、Caffeine。

# sql

```sql
SELECT * FROM 学生表 WHERE 学号 LIKE '%[^235]' //从学生表表中查询学号的最后一位不是2、3、5的学生信息。
```

### SQL语句执行顺序

FROM - ON - JOIN - **WHERE** - GROUP BY - WITH - **HAVING** - **SELECT** - DISTINCT - ORDER BY - LIMIT

```sql
(``8``) SELECT (``9``) DISTINCT
(``1``) FROM
(``3``) JOIN
(``2``)  ON
(``4``) WHERE
(``5``) GROUP BY
(``6``) WITH {CUBE|ROLLUP}
(``7``) HAVING
(``10``) ORDER BY
(``11``) LIMIT
```

### 聚合函数结果作为筛选条件时，不能用where，而是用having语法















